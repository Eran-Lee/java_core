package com.eran.grammer;

/**
 * 加载方法不等于执行方法，初始化变量则会赋值
 *             类加载顺序应为 加载静态方法-初始化静态变量-执行静态代码块
 *             实例化时 先加载非静态方法-实例化非静态变量-执行构造代码块-执行构造函数
 * @author panteng
 *
 */
public class StaticTest {
    /**第一个加载*/
    public static int k = 0;
    /**第二个加载，因为是new一个实例，
     * 首先初始化j 打印出  1:j i=0 n=0
     * 执行构造块     打印出  2:构造快 i=1 n=1
     * 执行构造方法 打印出  3:t1 i=2 n=2
     * 实例化完成
     */
    public static StaticTest t1 = new StaticTest("t1");
    /**第三个加载 过程同上
     * 首先初始化j 打印出  4:j i=3 n=3
     * 执行构造块     打印出  5:构造快 i=4 n=4
     * 执行构造方法 打印出  6:t2 i=5 n=5
     */
    public static StaticTest t2 = new StaticTest("t2");
    /**第四个加载
     * 打印出  7:i i=6 n=6
     */
    public static int i = print("i");
    /**
     * 第五个加载
     */
    public static int n = 99;
    /**
     * 此变量在类加载的时候并不初始化，在实例化类的时候初始化
     */
    public int j = print("j");
     
    {
        print("构造快");
    }
    /**
     * 第六个加载 此时，n已经被初始化  所以打印出
     * 8:静态块 i=7 n=99
     */
    static{
        print("静态块");
    }
    //-----------以上属于类加载---------------------
    /**
     * 实例化过程：
     *         首先加载非静态方法集；
     *         初始化非静态变量：9:j i=8 n=100
     *         执行构造块：10:构造快 i=9 n=101
     *         执行构造方法:11:init i=10 n=102
     * 实例化完成
     */
    
    /**
     * 执行构造函数  实例化完成
     * @param str
     */
    public StaticTest(String str) {
        System.out.println((++k) + ":" + str + " i=" + i + " n=" + n);
        ++n;
        ++i;
    }
    /**
     * 这个应该是最先加载 但是，加载不等于执行
     * 因为如果不加载此函数，静态变量是无法初始化的
     * @param str
     * @return
     */
    public static int print(String str) {
        System.out.println((++k) + ":" + str + " i=" + i + " n=" + n);
        ++i;
        return ++n;
    }
    
    public static void main(String[] args) {
        /**首先加载类，然后实例化：
         * 类加载过程：
         *         首先加载所有的静态方法，但不执行；
         *         然后按照静态变量的顺序开始初始化
         *         静态变量初始化完毕后执行静态构造块（不执行构造块）
         *         此时类加载完毕
         * 实例化过程：
         *         加载非静态方法
         *         初始化非静态变量
         *         执行构造代码块
         *         执行构造函数
         *         此时实例化完毕
         */
        StaticTest t = new StaticTest("init");
    }
    
    /* 我 们都知道一个java程序运行要经过编译和执行，但是这太概括了，中间还有很多步骤，今天来说说类加载,以后就要说：编译》加载（又分为加载、连接、初始化）》执行
     * 1.类加载过程：
     * 		<1>大概可以描述为如下几步：编译-加载-连接(这一步可以细分为验证、准备、解析)-初始化
     * 		<2>编译：将Java文件编译为class文件；
     * 		<3>加载：jvm利用ClassLoader加载编译后的二进制.class文件到内存中。
     * 		<4>连接：这是复制且重要的一步
     * 				1.验证：验证.class文件的合法性。
     * 				2.准备：为类的静态变量分配内存，将其初始化为默认值 。
     * 				3.解析：把类中的符号引用转化为直接引用。
     * 		<5>初始化：为类的静态变量赋予正确的初始值，上述的准备阶段为静态变量赋予的是虚拟机默认的初始值，此处赋予的才是程序编写者为变量分配的真正的初始值
     * 
     * 2.类加载的内存分析
     * 	<1>.方法区：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据
     * 	<2>.堆区：存放对象实例，几乎所有的对象实例都在这里分配内存
     *  <3>.也就是说，类被加载后，方法区会被分出一块内存，存储这个类的所有信息，但是这个内存块存储的依然是.class文件，并不能被我们使用，我们还需要一个能被直接使用的对象，
     *  此时堆区就开始发挥作用。类的信息被存储在方法区后，jvm虚拟机又会堆区创建一个java.lang.Class对象，这个对象就好像方法区对应类的一个镜子，把方法区存储的类的结构
     *  全部反射过来，然后封装起来，成为了一个Class类的对象（此处运用到反射知识）。这个Class对象与对应的类是一对一服务，因为他有类的结构信息，所以他自然可以构造出
     *  一个类的对象。我们平时使用的对象就是由这个Class类的对象生成。到此，类的加载已经完成，我们new一个对象实际上是使用了这个Class类对象进行操作的。
     *  <4>总结,类加载的最终产品是在堆中Class对象。Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。
     *  
     * 3.所有的Java虚拟机实现必须在每个类或接口被Java程序“ 首次主动使用”时才初始化他们
	 * 		<1>Java程序对类的调用
	 * 			——主动使用
	 * 			——被动使用
	 * 		<2>主动使用的情况
	 * 			——创建类的实例
	 * 			——访问某个类或接口的静态变量，或者对该静态变量赋值
	 * 			——调用静态方法
	 * 			——反射
	 * 			——初始化一个类的子类
	 * 			——Java虚拟机启动时被标明为启动类的类
     * 			
     */	
 
}